///--------------------------------------------- Legend
// +X     =>  1 or more of X
// *X     =>  0 or more of X
// ?X     =>  0 or 1 of X
// ( .. ) =>  group - treated as a single entity
// X | Y  =>  X or Y
// X - Y  =>  X excluding Y
// 'X'    =>  'X' single character literal
// .X     =>  .X multi-character literal

/// Syntax Grammar
// ** all white space between tokens is ignored unless specified **

zombie-file
    +decl .Eof

decl
    kv-pair | macro-decl | .Comment

kv-pair
    string assignment

assignment
    '=' value separator

value
    string | object | array | .Number | macro-use

object
    '{' *kv-pair '}'

array
    '[' ?( value *( separator value ) ?separator ) ']'

macro-decl
    macro-key ?macro-decl-params assignment

macro-key
    '$' string

macro-decl-params
    '(' string *( separator string ) ?separator ')'

macro-use
    macro-key ?macro-use-params *key-accessor

macro-use-params
    '(' param *( separator param ) ?separator ')'

param
    string | macro-use

key-accessor
    '.' ( string | .Number )

separator
    ',' | newline

string
    bare_string | quoted_string

bare_string
    +( character - delimiter )

quoted_string
    '"' escaped_string '"'

escaped_string
    *( *( character - escape ) *( '\' escape ) )

character
    0x20...0x10FFFF

escape
    '"' | '\' | 'b' | 'f' | 'n' | 'r' | 't' | 'u' hex hex hex hex

hex
    0-9 | 'A'...'F' | 'a'...'f'

delimiter
    '\t'  // 0x09 .Tab
    '\n'  // 0x0A .LineFeed
    '\r'  // 0x0D .CarriageReturn
    ' '   // 0x20 .Space
    '"'   // 0x22 .Quote
    '$'   // 0x24 .Dollar
    '('   // 0x28 .OpenParen
    ')'   // 0x29 .CloseParen
    ','   // 0x2C .Comma
    '.'   // 0x2E .Dot
    '='   // 0x3D .Equals
    '['   // 0x5B .OpenSquare
    '\'   // 0x5C .ReverseSolidus
    ']'   // 0x5D .CloseSquare
    '{'   // 0x7B .OpenCurly
    '}'   // 0x7D .CloseCurly

newline
    '\n' | '\r\n'


/// Lexical Grammar (Tokens)

// .String cannot contain any of these - use a quoted .String instead
.Comma              -> ,
.Dot                -> .
.Dollar             -> $
.Equals             -> =
.Quote              -> "  (must be escaped in a quoted string)
.OpenCurly          -> {
.OpenParen          -> (
.OpenSquare         -> [
.CloseCurly         -> }
.CloseParen         -> )
.CloseSquare        -> ]
.WhiteSpace         -> 0x20 | \t
.Newline            -> \n | \r\n

.Comment            -> // <any unicode codepoint>* .NewLine
.String             -> <any unicode character, except "special" bytes must be escaped with '\'>* (this is likely incorrect - if a string is to contain any "special" bytes, it must be quoted, not escaped)
.Number             -> 0 | 1-9 ( 0-9 )*

EOF                 -> <end of the file>

// PATTERNS

$KEY(PARAM PARAM) = VALUE      -> A "Macro" with parameters.
$KEY = { KEY = VALUE }          -> A "Macro Object".
$KEY = [ VALUE VALUE $KEY ]   -> A "Macro Array".

KEY = VALUE                     -> A key-value pair
"KEY" = VALUE                   -> A key-value pair (with a quoted KEY)
KEY = { KEY = VALUE }           -> A key-object pair.
KEY = [ VALUE VALUE VALUE ]   -> A key-array pair.
KEY = $KEY                      -> Using an entire "Macro" or "Macro Object" or "Macro Array" as a value.
KEY = $KEY.KEY                  -> Using a field from a "Macro Object" as a value.
KEY = $KEY.0                    -> Using an index from a "Macro Array" as a value.
KEY = $KEY(VALUE $KEY)         -> Using a "Macro Function" with a regular value and a "Macro" or "Macro Object" or "Macro Array" or "Macro Function" as a value

// Simple recursion -- forbidden

$name(n) = {
    name = $name($n)  <-- found outer function used inside the same function
}

// Nested recurssion -- forbidden
//
//  my_name = $name(Zooce)
//
//  -> $name(Zooce) -> $cool_person(Zooce) -> $name(Zooce)
//     ^......................................! Error: `$name` is already in this macro chain. All recursion is forbidden.

$name(n) = {
    name = $cool_person($n)  <-- inner function call also calls the outer function (and vise versa)
}
$cool_person(p) = {
    cool = $name($p)  <-- inner function call also calls the outer function (and vise versa)
}

// Special delimiters that can only be used in KEYs or VALUEs that are double-quoted

'\t' = 0x09 = ✓ -> Horizontal Tab
'\n' = 0x0A = ✓ -> Line Feed
'\r' = 0x0D = ✓ -> Carriage Return
' '  = 0x20 = ✓ -> Space
'"'  = 0x22 = ✓ -> Quotation Mark
'$'  = 0x24 = ✓ -> Dollar Sign
'('  = 0x28 = ✓ -> Left Paren
')'  = 0x29 = ✓ -> Right Paren
','  = 0x2C = ✓ -> Comma
'.'  = 0x2E = ✓ -> Full Stop
'/'  = 0X2F = ✓ -> Solidus (x2)
'='  = 0x3D = ✓ -> Equal Sign
'['  = 0x5B = ✓ -> Left Square
']'  = 0x5D = ✓ -> Right Square
'{'  = 0x7B = ✓ -> Left Curly
'}'  = 0x7D = ✓ -> Right Curly

// Random Notes

To separate key-value pairs, we require a comma, newline, or ending the enclosing set, object, or array with the corresponding right bracket.

// Parsing

STRING = STRING
^----^   ^----^
     |        |...String Value
     |............Identifier

STRING = { STRING = value, DOLLAR STRING = value }
^----^   ^ ^----^   ^---^^ ^-----------^   ^---^ ^
     |   |      |       ||             |       | |...Object End
     |   |      |       ||             |       |...Value (Can be pretty much anything)
     |   |      |       ||             |...Macro Identifier
     |   |      |       ||...Comma (separates key-value pairs)
     |   |      |       |...Value (Can be pretty much anything)
     |   |      |...Identifier
     |   |...Object Begin
     |...Identifier

// -- Macro

DOLLAR STRING = STRING
^-----------^   ^----^
            |        |...String Value
            |............Macro Identifier

// -- Macro Object

DOLLAR STRING = { STRING = value }
^-----------^   ^ ^----^   ^---^ ^
            |   |      |       | |...Object End
            |   |      |       |...Value (Can be pretty much anything)
            |   |      |...Identifier
            |   |...Object Begin
            |...Macro Identifier

// How are we going to parse the tokens?

Stack                  | Token  | Match                    | Action
-----------------------|--------|--------------------------|-------
(empty)                | '$'    | Macro (partial)          | Push
'$'                    | 'name' | Macro (full)             | Push
'$' 'name'             | '('    | Macro Function (partial) | Push
'$' 'name' '('         | 'n'    | Macro Function (partial) | Push
'$' 'name' '(' 'n'     | ')'    | Macro Function (full)    | Push
'$' 'name' '(' 'n' ')' | '='    | None                     | Flush


State {
    MacroId,        // stack = [ DOLLAR, STRING ]
    MacroFuncId,    // stack = [ DOLLAR, STRING, OPEN_PAREN ]
}

Parser {
    parse(tokenizer) {
        while (tokenizer.next()) |token| {
            if (stack.evaluate(token)) {
                stack.push(token)
            } else {
                stack.
            }
        }
    }
}

self.stack = ArrayList.init(&allocator);

token = tokenizer.next();
switch (self.state) {
    .Decl => {
        switch (token) {
            .Dollar => {
                self.stack.push(token);
                token = tokenizer.next();
                if (token != TokenString) {
                    return InvalidMacroIdentifier;
                }
                self.stack.push(token);
                self.state = States.
            },
            .String => self.state = States.Pair,
            .Comment => {},
            else => return Error.InvalidDeclaration,
        }
        self.stack.push(token);
    },
    .MacroId => {
        if (token != Token.String) {
            return InvalidMacroIdentifier,
        }
        self.stack.push(token);
        self.state = States.MacroDecl;
    },
    .MacroDecl => {
        switch (token) {
            .Equals => self.state = States.MacroDef,
            .OpenParen => self.state = States.MacroFuncParam,

        }
    }
}

for (stack) |token| {
    switch (token) {
        .Dollar =>
    }
}

////////

// no params
$macro1 = value
$macro2 = { key = value }
$macro3 = [ value0, value1 ]

key = $macro1  ->  key = value
key = $macro2  ->  key = { key = value }
key = $macro3  ->  key = [ value, value ]

// params
$macro4(a) = $a
$macro5(a) = { key = $a }
$macro6(a) = [ value0, $a ]

key = $macro4(a)  ->  key = a
key = $macro5(a)  ->  key = { key = a }
key = $macro6(a)  ->  key = [ value, a ]

// macro member acccess
key = $macro2.key     ->  key = value
key = $macro3.1       ->  key = value1
key = $macro5(a).key  ->  key = a
key = $macro6(a).0    ->  key = value0


////// Testing out separator syntax

/// No commas - what kinds of weird things can I do

// basics

// this is okay - but depending on the values, might be a little weird
key = [ v1 v2 v3 ]

key = [ v1, v2
    v3]

// this sucks, but that's okay because you can't do this anyways [1]
//  [1]: assignment is defined as `.Equals ws* value .Newline` << a newline is required after an assignment
key = { a = 1 b = 2 c = 3 }

// the macro declaration here is okay - something about no commas between parameters seems weird...
$macro(p1 p2 p3) = {
    a = $p1
    b = $p2
    c = $p3
}

// again this is okay, but something is weird here - maybe commas would be a better idea for parameters
key = $macro(hello there friend)

// ....yea this is better
key = $macro(hello, there, friend)

// we should probably allow this in case we have some longer usage of macros as a parameter..
key = $macro(
    hello,
    there,
    $some_longer_macro
        ( need, more, structure,
          $again_wtf_long_macro_name(for, the, params),
)
